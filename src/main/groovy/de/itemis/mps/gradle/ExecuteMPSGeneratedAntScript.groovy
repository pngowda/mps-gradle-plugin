package de.itemis.mps.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.file.FileCollection
import org.gradle.api.tasks.OutputFiles
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.TaskAction
import org.apache.tools.ant.Project
import org.apache.tools.ant.ProjectHelper
import org.gradle.api.tasks.incremental.IncrementalTaskInputs

class ExecuteMPSGeneratedAntScript extends DefaultTask {
    Object script
    Object cmdargs
    List<String> targets = Collections.emptyList()
    def IOoutputPropertyMap =[keyB: 'valueB']
    List<File> inputResolvedFileList =new ArrayList<File>()
    List<File> outputResolvedFileList =new ArrayList<File>()
    FileCollection IOFilesToReturn = getProject().files();

    def targets(String... targets) {
        this.targets = Arrays.asList(targets)
    }

    /**
    * This method reads "input" node elements from *_incrementalIO.xml file generated by MPS build script generator and resolve the
    * each input file path, creates a list and define all of them as InputFiles with the help of annotation for the Gradle to work incrementally.
    * This block gets executed only if incremental build is enabled with the command line option "-Pincremental" and corresponding *_IO.xml file
    * exist for each of the generated ant build file. Otherwise it just creates a temporary file and marks it as input which is essential
    * to trigger a rebuild in the nonincrementl mode. (Note: temp file creation is just a workaround for time being)
    * @return: list of Inputs for Gradle incremental build
    */
    @InputFiles
    def getInputFiles(){
        logger.debug("Input Calculation")
        def antBuildFile = project.file(script)
        def generatedIOXMLFile = new File(antBuildFile.getParent() + File.separator + antBuildFile.getName().split("\\.")[0] + "_incrementalIO.xml")
        if (project.hasProperty('incremental') && generatedIOXMLFile.exists()) {
            getProperties(antBuildFile)
            parseAntBuildXmlFileInput(generatedIOXMLFile)
            for (f in inputResolvedFileList) {
                IOFilesToReturn = IOFilesToReturn.plus(getProject().fileTree(new File(f)));
            }
            return IOFilesToReturn;
        } else{
            if(!project.hasProperty('incremental'))logger.info("Incremental mode is disabled.")
            if(!generatedIOXMLFile.exists())logger.info("Input-Output xml file is missing.")
            for (File f : (project.file(System.getProperty("user.dir")+File.separator+".gradle")).listFiles()) {
                if (f.getName().startsWith("temp_input")|| f.getName().startsWith("temp_output") ) {
                    f.delete();
                }
            }
            def tempFile=File.createTempFile("temp_input", ".tmp", project.file(System.getProperty("user.dir")+File.separator+".gradle"))
            IOFilesToReturn = IOFilesToReturn.plus(getProject().fileTree(tempFile));
            return IOFilesToReturn
        }
    }

    /**
     * This method reads "output" node elements from *_incrementalIO.xml file generated by MPS build script generator and resolve the
     * each input file path, creates a list and define all of them as InputFiles with the help of annotation for the Gradle to work incrementally.
     * This block gets executed only if incremental build is enabled with the command line option "-Pincremental" and corresponding *_IO.xml file
     * exist for each of the generated ant build file. Otherwise it just creates a temporary file and marks it as input which is essential
     * to trigger a rebuild in the nonincrementl mode. (Note: temp file creation is just a workaround for time being)
     * @return: list of Outputs for Gradle incremental build
    */
    @OutputFiles
    def getOutputFiles(){
        logger.debug("Output Calculation")
        def buildFilePath = project.file(script)
        def ioFile = new File(buildFilePath.getParent() + File.separator + buildFilePath.getName().split("\\.")[0] + "_incrementalIO.xml")
        if (project.hasProperty('incremental') && ioFile.exists()) {
            getProperties(buildFilePath)
            parseAntBuildXmlFileOutput(ioFile)
            for (f in outputResolvedFileList) {
                IOFilesToReturn = IOFilesToReturn.plus(getProject().fileTree(new File(f)));
            }
            return IOFilesToReturn;
        } else {
            if(!project.hasProperty('incremental'))logger.debug("Incremental mode is disabled.")
            if(!ioFile.exists())logger.debug("Input-Output xml file is missing.")
            def tempFile=File.createTempFile("temp_output", ".tmp",project.file(System.getProperty("user.dir")+File.separator+".gradle") )
            IOFilesToReturn = IOFilesToReturn.plus(getProject().fileTree(tempFile));
            return IOFilesToReturn
        }
    }

    /**
    *This method reads properties from ant build script and from global custom properties and creates hashmap with
    *property key and its value pair which could later be used in IO xml file to resolve the paths of all
    *inputs and outputs defined.
    */
    def getProperties(ioFilePath) {
        String cmdArgData = cmdargs.toString();
        def antInputPropertyMap =[keyA: 'valueA']
        def customInputGlobalPropMap = [keyC: 'valueC']
        logger.debug("Global custom Arguments: "+cmdArgData)
        cmdArgData.splitEachLine(",") {
            it.each { x ->
                def object = x.split("=")
                customInputGlobalPropMap.put(object[0].split("-D").getAt(1), object[1])
            }
        }
        def antProject = new Project()
        ProjectHelper.configureProject(antProject, ioFilePath)
        antInputPropertyMap = antProject.getProperties()
        antInputPropertyMap.each { keyA, valueA ->
            if (customInputGlobalPropMap.containsKey(keyA)) {
                IOoutputPropertyMap.put("\${" + "$keyA" + "}", customInputGlobalPropMap.get(keyA))
            } else {
                IOoutputPropertyMap.put("\${" + "$keyA" + "}", "$valueA")
            }
        }
    }

    /**
    *Parse each IO xml file for the corresponding ant build xml and substitute the value of property
    *macros with its corresponding values to get the resolved Input file paths.
    */
    def parseAntBuildXmlFileInput(ioFilePath){
        def parsedProjectXml = new XmlSlurper().parse(ioFilePath)
        def inputIOFileList=new ArrayList()
        parsedProjectXml.input.file.each { file -> inputIOFileList.add(file.@path) }
        inputIOFileList.each {
            if (it.toString().contains("\$")) {
                def toResolveString = it.toString().split("/").getAt(0)
                def resolvedPath = it.toString().replace(toResolveString, IOoutputPropertyMap.get(toResolveString))
                logger.debug("Input File: "+resolvedPath)
                inputResolvedFileList.add(resolvedPath)
            }
        }
    }

    /**
    *Parse each IO xml file for the corresponding ant build xml and substitute the value of property
    * macros with its corresponding values to get the resolved Output file paths.
    */
    def parseAntBuildXmlFileOutput(ioFilePath){
        def parsedProjectXml = new XmlSlurper().parse(ioFilePath)
        def outputIOFileList=new ArrayList()
        parsedProjectXml.output.file.each { file -> outputIOFileList.add(file.@path) }
        outputIOFileList.each {
            if (it.toString().contains("\$")) {
                def toResolveString = it.toString().split("/").getAt(0)
            def resolvedPath = it.toString().replace(toResolveString, IOoutputPropertyMap.get(toResolveString))
                logger.debug("Output File: "+resolvedPath)
                outputResolvedFileList.add(resolvedPath)
            }
        }
    }

    /**
    *Task action which calls an ant process to run the build for incremental and rebuild case. For incremental mode,
    *it would also list the new/modified/removed files when run with debug option.
    */
    @TaskAction
    def build(IncrementalTaskInputs inputs) {
        println inputs.incremental ? "CHANGED inputs considered out of date"
            : "ALL inputs considered out of date"
        inputs.outOfDate { change ->
            logger.debug("out of date: ${change.file.name}")
        }
        inputs.removed { change ->
            logger.debug("removed: ${change.file.name}")
        }
        spawnAnt()
    }

    /**
    * Method which spawns an ant process to run  build with corresponding command line arguments, ant build xml
    * and targets to be executed for each ant script.
    */
    def spawnAnt() {
        project.javaexec {
            main 'org.apache.tools.ant.launch.Launcher'
            workingDir project.rootDir

            classpath project.configurations.ant_lib.fileCollection({
            true
            }) + project.files("$project.jdk_home/lib/tools.jar")

            args(*['-verbose', *cmdargs , '-buildfile', project.file(script), *targets])
        }
    }
}
